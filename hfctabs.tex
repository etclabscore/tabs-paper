\documentclass[11pt]{article}
\usepackage{amsmath}

\usepackage{algorithm}
%\usepackage{algpseudocode}}

\usepackage[framemethod=TikZ]{mdframed}
\mdfdefinestyle{MyFrame}{%
    linecolor=blue,
    outerlinewidth=1pt,
    roundcorner=10pt,
    innertopmargin=\baselineskip,
    innerbottommargin=\baselineskip,
    innerrightmargin=20pt,
    innerleftmargin=20pt,
    backgroundcolor=white}

\makeatletter
\def\BState{\State\hskip-\ALG@thistlm}
\makeatother
\usepackage{hyperref}
\hypersetup{colorlinks=true,linkcolor=blue,urlcolor=blue}

\usepackage{amsfonts}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsthm}
\usepackage{bbm}
\usepackage{xcolor}
%\usepackage[dvipsnames]{xcolor}
\usepackage{longtable}
\usepackage{booktabs, caption, makecell}
\renewcommand\theadfont{\bfseries}
\usepackage{threeparttable}
\DeclareMathAlphabet{\mathpzc}{OT1}{pzc}{f}{it}
\DeclareMathOperator*{\argmax}{argmax}
\usepackage{appendix}
\newtheorem{innercustomthm}{Theorem}
\theoremstyle{plain}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{parskip}% http://ctan.org/pkg/parskip 
\usepackage{adjustbox}
\usepackage{lipsum}
\usepackage{tabularx}
\usepackage{listings}
\newtheorem{exercise}{Exercise}
\newtheorem{proposition}{Proposition}[section]
\newtheorem{assumption}{Assumption}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[proposition]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{myassum}{Assumption}
\newtheorem{definition}{Definition}[section]
\newenvironment{customthm}[1]
{\renewcommand\theinnercustomthm{#1}\innercustomthm}
{\endinnercustomthm}


\usepackage{biblatex}
%\addbibresource{refs.bib}


%\usepackage[toc,page]{appendix}
%\usepackage{import}

\usepackage{geometry}
\usepackage{marginnote}

% This is a custom command to make multi-line comments.
% https://tex.stackexchange.com/questions/87303/multi-line-block-comments-in-latex
\newcommand{\comment}[1]{}

\newcommand{\mghost}{\textit{Modified-GHOST }}


\title{\textbf{Keeping TABS}\\
\small{A Canon-Arbitration Algorithm for \mghost Proof-of-Work Blockchain Protocols}}

%% NOMENCLATURE: "Keeping TABS" is a play on words.
%% The phrase is an english idiom used to describe a state of watchfulness or
%% reactive observation, as in: I must keep tabs on my bank account to ensure that
%% I understand my finanical status and to prevent miscalculations.
%% In the use of the conjugated form of the verb "to keep," we find also a
%% reference to the action of preservation, or a suggested state of permanence.
%% With this, the play on words ultimately suggests that observation of some
%% state is associated with the persistence of the state itself.
%% This is an effective and accurate illustration of both the means and ends of
%% this project.
%% In spite of the cost of explaining a joke, we hope this provides clarity for
%% non-native English readers and harmless interpretive confirmation otherwise.

\author{Isaac Ardis\
\and Daniel Aronoff\\\small{MIT Economics}\\\small{MIT Media Lab}}

\begin{document}

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\maketitle
\begin{abstract}

Canon-arbitration algorithms are used to build consensus in decentralized
state machines.
The consensus characteristics of mutually implemented canon-arbitration
algorithms enables a race between block authors and thereby facilitate
the trust-minimized security characteristics of the blockchain state.
In Proof-of-Work (PoW) block validation protocols canon-arbitration
algorithms typically depend on dynamic emission parameters like Difficulty,
facilitating a steady block emission rate for the network.

We proposed and evaluate a modification to the \mghost\footnote{
    \url{https://ethereum.org/en/whitepaper/#modified-ghost-implementation}}
algorithm used by Ethereum.
This proposal introduces two novel features: a capacity for segment-specific
transactions, and a positive scalar value representing a general measurement of
active capital per block.
From these features we construct a novel canon-arbitration strategy
which preserves the incumbent PoW chain-growth game
while improving the expected block finality rate by 50\%
and raising the cost of double-spend attacks.

We evaluate associated additional risk to the network,
which we show to be practically nominal.
A proof-of-concept code implementation of the protocol is drafted
for Ethereum's primary client \textit{go-ethereum}\footnote{
    \url{https://github.com/ethereum/go-ethereum}},
and is included with or easily referenced from this document.

%We note that implementation of this design is feasible for Ethereum's
%primary client \textit{go-ethereum} (\texttt{geth}) and probably feasible for
%most existing PoW clients.

%Our proposed design is an augmentation of an existing and widely implemented consensus program.
%As such, it assumes and depends on the existence of incumbent (canon-arbitration) algorithmic conditions.
%We inherit and generally preserve as invariants
%the characteristics of the incumbent canon-arbitration algorithm.

%We claim and attempt to demonstrate that the proposed algorithmic condition
%program raises the incumbent consensus decidability rate.
%We show that this increased decidability rate improves chain state finality
%characteristics and reduces network energy waste by 50\%.
%Further, we show that the cost to an adversary in a double-spend attack scenario rises.
%We detail any associated additional risk to the network, which we show to
%be practically nominal.
%We note that implementation of this design is feasible for Ethereum's
%primary client \textit{go-ethereum} (\texttt{geth}) and probably feasible for
%most existing PoW clients.

\end{abstract}

%\clearpage

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\comment{
Its about establishing capitalization as ONE OF the principles driving chain growth.

How do we measure capitalization?

Proofs of capital availability and dependence on chain state.
Potential for transaction/chain exclusivity; exclusive investment.

Should we tie capital (eg balance) more closely together with difficulty?

Ideas.

consensus score = difficulty * sum(block.txes[].from)=tab
consensus score = 2 * difficulty * tab

tab=sum(block.txes[](.gasUsed* .gasPrice * .from.balance))

what if tabs could rise or fall depending on if pow rose or fell?

If we assume no one controls 51\% or more of the hashrate...
    (it is obvious we cannot assume this anymore).
AND If we assume no one controls more than the median TAB measurement...
AND If we assume that (public, measurable) transactions are (have been made able to be) EXCLUSIVE to the public chain state.
Under these conditions we define the cost of an attack as:

    the cost of beating the public TABS value * the cost of beating the public proof of work race
    which is
    the median segment-exclusive capitalization rate * matching (100+e\%) the rate of block production
    which is
    if you can beat the segment-exclusive capitalization rate by 10\% (1.1), then you only need 0.9 * hashrate



For every x more blocks they can mark as TABS+ (compared to 50\% mean=median at public), they will get tabs*4097/4096,
which buys them a 1/4096 depreciable margin in PoW (they can take one computer offline).
That is, they can drop hashrate by 1/4096 of whatever they have online.

Publicly available capitalization: 299 txes => 299 ETH (really assume 299*avg(bal)).
Privately available capitalization: 1 txes => 1 ETH (miner coin capitalization == gen pop coin capitalization)
  ... but we shouldn't expect this? Because miners are incentivized to hodl, because now they get paid for it (in probabilities).
  ... should miner-private capitalization be expected to grow indefinitely? No, it has bounds.
      Assume that ALL of the miner's capital is in PoW tech, not coin.
      Assume that ALL of the miner's capital is in coin, not PoW tech. Do they mine any blocks? No.

If the competitor can NOT EXCEED the segment-exclusive capitalization rate,


On private-chain attacks:
It is more efficient to mine alone.

The "current TABS" adjustment algorithm defines +1/-1/n pattern,
where the parent TABS value is adjusted by some ratio of itself.
The current proposal is the median by definition.
It moves up when the TABS value exceeds the parent,
it drops when it falls short of the parent.
This is the definition of median.

What about using a a moving average algorithm.


---

We define two types of transactions: segment-exclusive and segment-agnostic.
The degree to which they are exclusive will matter, but is black and white at the atomic (one block) level.

In "normal" conditions, we assume that segment-agnostic transactions do not ever achieve 100\%.
Because: each miner agent has some private capital that they should apply only to blocks they produce; segment-exclusivity.



}

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{\normalsize{Model Definitions}}\label{sec: definitions}

\begin{table}[H]
\caption{List of Model Definitions\label{table: model-definitions}}
\centering
\small{
\begin{tabular}{|p{5cm}|p{9cm}|}

\hline
\multicolumn{2}{| c |}{Model Elements} \\
\hline
\hline
$t$ & Time. Standard unit: seconds. \\~\\

$\lambda$ & Network mean block time; the average number of seconds between
block timestamps. \\~\\

$\eta$ & Network block-message latency (measurable or assumed) between two
nodes. The time elapsed between the transmission of a message containing block
information and its reception. \\~\\

$B_i$ & A block with number $i$. \\~\\
$H_i$ & A block header with number $i$. \\~\\
$H_d$ & Block (and header) annotated difficulty. \\~\\
$H_{td}$ & Block (and header) annotated total difficulty. \\~\\
$H_k$ & Block (and header) annotated $\mathrm{TABS}$ value. \\~\\
$H_t$ & Block (and header) annotated timestamp value. \\~\\

$TAB(B)$ & A scalar value representing aggregated account balances for a given
block $B$. "TAB" stands for Total Active Balance. \\~\\
$TABS(B_i,B_{\mathrm{i-1}})$ & A scalar value derived from the $TAB$ value of
block $B_i$ and recursively its parent $B_{i-1}$. This value is annotated in a
block's header. "S" stands for \textit{synthetic} or \textit{synthesis}. \\~\\

$\sigma[a]$ & Global account state $\sigma$ at address $a$. \\~\\

$T$ & A transaction. \\~\\

$T_a$ & A proposed transaction field: Ancestor Hash.
See Glossary. \\~\\

$\delta(T_a)$ & The depth (magnitude of ancestry) of a block cited by some
transaction as $T_a$. \\~\\

$\tau$ & A network-level aggregate over time or segment (assume: average) of
Ancestor Hash depth $\delta$ values. Transactions \textit{not} asserting an
Ancestor Hash value can be defined as having $\delta$ = $H_i$.
Smaller values represent a greater dependence on blocks nearer a common
(consensus) chain head (a greater degree of transaction/segment exclusivity),
while larger values signal less exclusive transaction assertion on chain
state dependence.
\\~\\

$\mathrm{CS}$ & Canon Score. A scalar value representing canon preference
weight of a single block. Comparable to Difficulty. \\~\\

$\mathrm{TCS}$ & Total Canon Score. A scalar value representing protocol
canonical preference. Derivation of this value for any block relies on the
antecedent calculation of that of its parent. Comparable to Total Difficulty.
\\~\\

\hline
\end{tabular}
}
\end{table}

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{\normalsize{Verbal Glossary}}\label{sec: glossary}

\begin{table}[H]
\caption{Definitions of Common Terms\label{table: common-terms}}
\centering
\small{
\begin{tabular}{|p{5cm}|p{9cm}|}

\hline
\multicolumn{2}{| c |}{Glossary} \\
\hline
\hline

Ancestor Hash &
A proposed transaction field whose value references a block by hash,
specifying the existence of that block in the transaction's chain segment
as a condition of the transaction's validity.
Proposed.
Use optional.
Synonyms: Segment ID, HFC (Header Field Context) Hash.
Related: Chain ID.
\\~\\

AHA Transactions &
Ancestor Hash Appended transactions.
Transactions which implement the \textit{Ancestor Hash} field.
In Ethereum, such a transaction may be implemented as an EIP-2718 Typed Transaction.
\\~\\

Canonical-Arbitration Algorithm &
A program of comparative conditions resulting in the selection of one prioritized segment from any two segments.
In context, the prioritized segment is used as the basis for determining a canonical chain state,
and, as such, for focusing mining effort (via establishing a \textit{parent}.
Synonyms: Canonical-Preference Algorithm.
Related: GHOST, \mghost, Inclusive Protocol, Nakamoto Protocol.
\\~\\
%% $Canonical-Arbitration Algorithm & A program of comparative
%% conditions resulting in the selection of one prioritized segment from any two
%% segments. In context, the prioritized segment is used as the basis for
%% determining a canonical chain state, and, as such, for focusing mining effort
%% (via establishing a \textit{parent}. Synonyms: Canonical-Preference 
%% Algorithm.
%% Related: GHOST, Modified GHOST, Inclusive Protocol, Nakamoto Protocol. \\~\\

Segment-Agnostic (Transaction) &
A property on a transaction such that the transaction can be applied to one or more chain histories.
Related: Segment-Specific.
\\~\\

Segment-Specific (Transaction) &
A property on a transaction such that the transaction can be applied on a subset of available chain histories.
Synonyms: Segment-Exclusive, Chain Context Constrained.
Related: Segment-Agnostic.
\\~\\

Chain State Finality &
The permanence of chain state (or series of states).
PoW blockchain states have characteristically `soft` finality characteristics.
PoW finality expectations increase as relative state increases;
newer states are more vulnerable to change than older states.
\\~\\

Block Emissions &
The (rate of) production of blocks. Blocks are metadata associated with chain state modification sequences.
\\~\\

Decidability &
The frequency of ties in canon-arbitration during chain growth.
Narula et al. call this \emph{symmetry-breaking}.
Decidable scenarios are characterized by eventual network-level chain state consensus.
Undecidable scenarios are characterized by bifurcated (canonical) network chain states.
\\~\\

\hline
\end{tabular}
}
\end{table}


%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagebreak
\section{\normalsize{Visual Glossary}}\label{sec: visual-glossary}

\begin{figure}[tph]
    \centering
    \includegraphics[width=0.2\textwidth]{imgs/vis_block.png}
    \caption{A block}
    \label{fig:block}
\end{figure}

\begin{figure}[tph]
    \centering
    \includegraphics[height=1cm]{imgs/vis_tx.png}
    \caption{A transaction}
    \label{fig:tx}
\end{figure}

\begin{figure}[tph]
    \centering
    \includegraphics[width=0.2\textwidth]{imgs/vis_tx_set.png}
    \caption{Several transactions}
    \label{fig:txs}
\end{figure}

\begin{figure}[tph]
    \centering
    \includegraphics[width=0.2\textwidth]{imgs/vis_tx_set_sized.png}
    \caption{Several transactions representing relative gas consumption}
    \label{fig:txsgas}
\end{figure}

\begin{figure}[tph]
    \centering
    \includegraphics[width=0.2\textwidth]{imgs/vis_blocktxs.png}
    \caption{Transactions in a block}
    \label{fig:blocktxs}
\end{figure}

\begin{figure}[tph]
    \centering
    \includegraphics[width=1.0\textwidth]{imgs/vis_blocksegment.png}
    \caption{A block segment (chain)}
    \label{fig:blocksegment}
\end{figure}

\begin{figure}[tph]
    \centering
    \includegraphics[width=1.0\textwidth]{imgs/vis_blocksegment_forking.png}
    \caption{A block segment with forks}
    \label{fig:blocksegment_forks}
\end{figure}

\begin{figure}[tph]
    \centering
    \includegraphics[width=1.0\textwidth]{imgs/vis_blocksegment_forking_txs_sparse.png}
    \caption{A block segment with forks and sparse transactions}
    \label{fig:blocksegment_forks_txs_sparse}
\end{figure}

\begin{figure}[tph]
    \centering
    \includegraphics[width=1.0\textwidth]{imgs/vis_blocksegment_forking_txs_full.png}
    \caption{A longer block segment with forks and full of transactions}
    \label{fig:blocksegment_forks_txs_full}
\end{figure}


\begin{figure}[tph]
    \centering
    \includegraphics[width=1.0\textwidth]{imgs/vis_blocksegment_forking_reorg.png}
    \caption{Block composition of a large reorg (eg. finality attack)}
    \label{fig:blocksegment_forks_reorg}
\end{figure}

\begin{figure}[tph]
    \centering
    \includegraphics[width=1.0\textwidth]{imgs/vis_blocksegment_forking_reorg_txs.png}
    \caption{Block composition of a large reorg (eg. finality attack) including
    transactions.
    The `fraudulent` modified or omitted (censored) transaction is red.
    %should we identify the transaction on the fork that empties the address from
    which the double-spend was made?
    }
    \label{fig:blocksegment_forks_reorg_txs}
\end{figure}

\begin{figure}[tph]
    \centering
    \includegraphics[width=1.0\textwidth]{imgs/vis_blocksegment_forking_reorg_t.png}
    \caption{Block composition of a large reorg (eg. finality attack), noting a
    value $t$ representing some point in time.
    Since the domain of this visualization is (implicity) block number, we deduce
    that the gray (top) chain has built more blocks per unit of time than its
    counterpart.
    The value of time $t$ in this case can be understood as an arbitrary instant
    where the segments (via their head blocks) are evaluated for canonical status.
    }
    \label{fig:blocksegment_forks_reorg__t}
\end{figure}

\begin{figure}[tph]
    \centering
    \includegraphics[width=1.0\textwidth]{imgs/vis_blocksegment_forking_reorg_anchash.png
    }
    \caption{Two illustrations of transaction inclusion under the large reorg
    scenario and assuming successively aggressive $\tau$ rates (composite frequency
    and value of the proposed Transaction Ancestor Hash field and validation).
    }
    \label{fig:blocksegment_forks_reorg_anchash}
\end{figure}

\begin{figure}[tph]
    \centering
    \includegraphics[width=1.0\textwidth]{imgs/vis_blocksegment_canonpref_abstract.png}
    \caption{
        A component diagram of block and transaction occurrences under the assumed
        reorg scenario with transactions using Ancestor Hash.
    }
    \label{fig:blocksegment_forks_canonpref_abstract_ex}
\end{figure}

\begin{figure}[tph]
    \centering
    \includegraphics[width=1.0\textwidth]{imgs/vis_blocksegment_canonpref_incumbent_ex.png}
    \caption{Visual conceptualization of the incumbent canon-arbitration
    initial condition using Total Difficulty values.
    }
    \label{fig:blocksegment_forks_canonpref_incumbent_ex}
\end{figure}


\begin{figure}[tph]
    \centering
    \includegraphics[width=1.0\textwidth]{imgs/vis_blocksegment_canonpref_proposed_ex.png}
    \caption{Visual conceptualization of the proposed canon-arbitration initial
    condition using Difficulty and TABS values.
    }
    \label{fig:blocksegment_forks_canonpref_proposed_ex}
\end{figure}

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{\normalsize{Scenarios}}\label{sec: scenarios}

\begin{table}[H]
\caption{Abstracts of Referenced Chain State Scenarios \label{table: chainstate-scenarios}}
\centering
\small{
\begin{tabular}{|p{5cm}|p{9cm}|}

\hline
\multicolumn{2}{| c |}{Scenarios} \\
\hline
\hline

Finality Fraud & A premeditated fraud scheme exploiting a victim's
assumption of chain state which is later invalidated by the attacker.
The exemplary scenario defined and reused throughout this paper assumes a single
entity as a victim and a single censored transaction.
In most contexts, these assumed parameters could be modified to use a plural set of victim entities
and/or a plural set of censored transactions while still being considered Finality Fraud.
\\~\\

Finality Terrorism & Generally schematically equivalent to Finality
Fraud; the difference is in the attacker's motive and an intentionally large number of victims.
The exemplary scenario defined and reused throughout this paper
assumes all users of a blockchain as victims and the censorship of all transactions.
These parameters are extremes.
In most contexts, these assumed parameters could be modified while still being considered Finality Terrorism.
\\~\\

\hline
\end{tabular}
}
\end{table}

%% \pagebreak
%% \section{\normalsize{Proposal Context}}

%% \subsection{\small{Related Works}}\label{sec: S1.-1}

%% - Eyal and Sirer: Thwarting Selfish Mining with a Coin-Toss \\
%% - Freshness-Preferred. (Cited for augmentative structure of proposal; not
%% for risk costs or security characteristics.)

%% \subsection{\small{Inherited Assumptions}}\label{sec: S1.0}

%% We assume in all non-general cases theoretical inheritance from the Ethereum
%% (ETH) protocol, which differs only trivially in this context from the 
% Ethereum
%% Classic (ETC) protocol.\footnote{https://github.com/ethereum/yellowpaper}

%% As noted in the Abstract, we take this context for granted as a necessary
%% assumption for the sake of argument.
%% However, we hypothesize, but do not attempt to show, the parameters and
%% validity of a more general case (eg. applicable for most PoW protocols).

%% We assume that all players in the presented theoretical games are
%% self-interested and infinitely greedy.

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagebreak
\section{\normalsize{Specifications}}\label{sec: specs}

In this section we describe the elements of the $TABS$ modification to the
\mghost algorithm.

\subsection{\small{TABS Validation}}

% TABS must change more slowly than Difficulty, per block.
% TABS should be able to fall more quickly than rise.

Total Active Balance Synthesis (TABS) is a positive scalar value.
It is a representative aggregate of all transacting-originating accounts for a blockchain of some length.
Generally considered, it provides a representative measure of active capital on some chain state.
It is denominated in Wei.\footnote{
    1000000000000000000 (1e18) Wei equal 1 Ether. % See \url{https://ethereum.stackexchange.com/questions/253}
}
Its value is used as a parameter in the proposed canon-arbitration condition.

\newcommand{\minTABS}{K_0}
\newcommand{\mynumerator}{y}
\newcommand{\tabsAdjustmentDenominator}{r}
\newcommand{\diffadjustment}{x}

Validation of the TABS value of a block of header $H$ is asserted as
$\mathrm{TABS}(H)$, \\

where:
\begin{equation}
\mathrm{TABS}(H) \equiv \begin{cases}

%\minTABS & \text{if} \quad %% H_{\mathrm{i}} = 0 \, \vert\vert \,P(H)_{H_k} \text{ is undefined} \\
\minTABS & \text{if} \, P(H)_{H_k} \, \text{is undefined} \\

\text{max}\!\left(\minTABS, {P(H)_{\mathrm{H}}}_{\mathrm{k}} +
\diffadjustment \mynumerator \right) & \text{otherwise} \\
\end{cases}
\end{equation}

where:
\begin{equation}
\minTABS \equiv 128\times 10^{18}
\end{equation}

\begin{equation}
    \tabsAdjustmentDenominator \equiv 4096
%    \begin{cases}
%        2048 & \text{if} \quad \lVert P(H)_{\mathbf{U}}\rVert = 0 \\
%        1028 & \text{otherwise} \\
%    \end{cases}
\end{equation}

\begin{equation}
\diffadjustment \equiv
\left\lfloor\frac{{P(H)_{\mathrm{H}}}_{\mathrm{k}}}{\tabsAdjustmentDenominator}\right\rfloor
\end{equation}

\begin{equation}
y \equiv
\begin{cases}
-1 & \text{if} \, $TAB(B)$ \, < \, $P(H)_{H_k}$ \\
0 & \text{if} \, $TAB(B)$ \, \equiv \, $P(H)_{H_k}$ \\
1 & \text{if} \, $TAB(B)$ \, > \, $P(H)_{H_k}$ \\
\end{cases}
\end{equation}

The \mathrm{TAB(B)} value of a block is defined as the sum of balances
of transaction-sending accounts for a block:

\begin{equation}
TAB(B) \equiv \sum_{T \in B_{\mathrm{txes}}}
L(B,T_{\mathrm{sender}})
\end{equation}

where:

\begin{equation}
L(B,s) \equiv P(B)_{\sigma[s]_{\mathrm{b}}} \quad \text{The account state
balance at parent block $P(B)$ of account $s$} \\
\end{equation}

%The reader may note that the integer \texttt{128} appears shared between the
%$x$ and $K_0$ components.
%This is not of necessity, but of convenience and for simplicity of design.
%Both values are tuneable constant parameters in the algorithm.
$K_0$ expresses an arbitrary minimum value for $TABS$,
while $x$ expresses an adjustment ratio of the $TABS$ value between two parent-child related blocks.

%% TODO/Isaac maybe move me to a Discussion section,
%% ie. Why we picked 4096 for this value, and what happens if the value were different (esp. smaller = bigger change).
The constant $\tabsAdjustmentDenominator$ is defined relative to
the minimum incumbent Ethereum difficulty adjustment factor (
    $\left\lfloor\frac{{P(H)_{\mathrm{H}}}_{\mathrm{d}}}{2048}\right\rfloor$
)
with $\tabsAdjustmentDenominator$'s definition designed
to maintain the precedence of the difficulty value in the resulting Canon Score product.
This ensures that difficulty remains the primary driver of chain growth,
keeping miner incentives invariant.

%The TABS adjustment mechanism is designed to closely imitate the behavior of block difficulty.
%However, the the rate of change of TABS values between blocks ($x$)
%must be less than that of difficulty.\footnote{
%For example, if the difficulty between blocks moves by a factor of $\pm1/2048$,
%then the TABS value should move by a factor of $<\pm1/2048$.
%}

\subsection{\small{Canon Arbitration}}

Canon-arbitration is the keystone of network consensus.

Canon-arbitration is defined as the comparison of two blocks, eventually yielding only one.
The resulting block is understood to be canonical, while any others competitive with it are not.
This section formally defines a value Canon Score \textit{CS}, which is used as
the \textit{initial condition} for a canon-arbitration algorithm.

In both the pre-existing and proposed algorithms, this condition may result in a tie.
If the condition is decisive (a winner is determined),
subsequent conditions are not evaluated.
If indecisive (the result is a tie), subsequent conditions are evaluated,
each potentially decisively, in program order.

For the sake of context, we write the assumed existing initial condition for
canon-arbitration in our notation below. The \textbf{pre-existing Canon Score value} is defined as:

\begin{equation}
\mathrm{CS} \equiv H_d
\end{equation}

And derived from that a Total Canon Score ($\mathrm{TCS}$) for any segment as:

\begin{equation}
\mathrm{TCS} \equiv \sum_{H_\mathrm{i = 0}}^{\mathrm{i <= n}} H_d
\end{equation}

Respective to this assumed pre-existing condition, \textbf{we propose its modification} as,

in the atomic case:

\begin{equation}
\mathrm{CS} \equiv H_d \times H_k
\end{equation}

and in the segment case:

\begin{equation}
\mathrm{TCS} \equiv \sum_{H_\mathrm{i = 0}}^{\mathrm{i <= n}} H_d \times H_k
\end{equation}

In both the pre-existing algorithm and the proposed algorithm, a candidate
block having a greater $\mathrm{TCS}$ value than the other should be selected for
the exclusive canonical state.

\subsection{\small{Transactions with Ancestor Hash Appended}}\label{subsec:small{transactions-with-ancestor-hash-appended}

The task of enabling transactions to accommodate chain-exclusivity (ie. segment-specificity)
as a protocol-level rule is addressed here.

Transactions are afforded an additional field $T_\mathrm{a}$ (\textit{Ancestor
Hash}) whose value either describes a block hash or is left undefined.\nolinebreak
\footnote{Original and complete specification, rationale, and motivation for this feature is
documented as a standalone proposal at \url{https://github.com/ethereumclassic/ecips/tree/master/_specs/ecip-1105.md}}

If a transaction defines $T_\mathrm{a}$, its validity is conditioned on
the existence of a block with this hash in the canonical chain
prior to the block including the transaction.

Transactions of this type are considered segment-specific.
The degree to which they are specific depends on which block is referenced by the hash is provided.
Transactions referencing relatively older blocks are less specific than those referencing newer ones.
The generalization of this concept is defined as $\tau$ (see Glossary).

As proposed, transactions are not required to provide this value.
However, discretionary use is not necessary.
The field's annotation \textit{could} be demanded by the protocol.

% "The chain I see is the chain I get."


% TODO
% Transaction senders are not expected to make any new assumptions beyond what is already practically exected.

% Transaction 'availability' technically drops. This is what it is.
% In this case, however, we present the reduction of transation availability as a feature, not a bug.

%We will show that $\tau$ drives desirable security characteristics of the proposed canon-arbitration protocol.

%TODO Useful to have a graphic description here

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagebreak
\section{\normalsize{Models}}\label{sec: models}

We model block emissions at the network level using a Poisson Distribution
(where independent mining, in aggregate, exemplifies a Poisson Process).\nolinebreak
\footnote{
Sources categorizing block emissions as a Poisson Process and/or Distribution: \\
    - Nakamoto. 'Bitcoin: A Peer-to-Peer Electronic Cash System', 2007.\\
    - Ren. 'Analysis of Nakamoto Consensus', 2019.\\
    - Gazi, Kiayias, Russel. 'Tight Consistency Bounds for Bitcoin', 2020.\\
    - Su, Liu, Narula. 'The Power of Random Symmetry-Breaking in Nakamoto Consensus', 2021.\\
%    \begin{itemize}
%        \item Nakamoto. 'Bitcoin: A Peer-to-Peer Electronic Cash System', 2007.
%        \item Ren. 'Analysis of Nakamoto Consensus', 2019.
%        \item Gazi, Kiayias, Russel. 'Tight Consistency Bounds for Bitcoin', 2020.
%        \item Su, Liu, Narula. 'The Power of Random Symmetry-Breaking in Nakamoto Consensus', 2021.
%    \end{itemize}
}

\subsection{\normalsize{Miner Expected Revenue}}

We naively define miner expected revenue over time $t$ (in seconds) as:

\newcommand{\minerHashrate}{Miner_{h/s}}
\newcommand{\networkHashrate}{Network_{h/s}}
\newcommand{\blockReward}{Block_\mathrm{reward}}
\newcommand{\blockTransactionFees}{Block_\mathrm{tx_fees}}

\begin{equation}
\frac{\minerHashrate}{\networkHashrate}
\times
P(E,t)
\times
P(C)
\times
(\blockReward + \blockTransactionFees)
\end{equation}

(Note that the ratio $\frac{\minerHashrate}{\networkHashrate}$ is intuitive but
naive, and can be further developed.)

\subsection{\normalsize{Probability of network block production}}

\begin{figure}[htp]
    \label{go-block-step-cdf-interval}
    \centering
    \includegraphics[width=1.0\textwidth]{go-block-step/out/vis_poisson_cdf_next_in_interval.png}
    \caption{
        A Poisson Cumulative Distribution Function (CDF) is used to model the probability of a block
        occurrence (y-axis) in some interval (x-axis).
        This plot is produced by the included Go test \texttt{TestPoissonCDFNextBlock}.
    }
\end{figure}

We assume that the occurrence of block events at the network level can be
modeled as a Poisson Process.\nolinebreak
\footnote{
One must note that while it may be granted that the model fits \emph{recorded}
network block interval data, it may not necessarily represent the \emph{actual}
production intervals. Neither must it represent accurately the production
interval of blocks by any subset of miners.
}
From this, we can define the probability of any block being discovered in an
interval of $t$ seconds given an event rate $r$ (such that $r * t = \lambda$)
as a derivation of the Poisson CDF.
%In this model, $k$ is held constant at $0$ signifying the occurence of 0
%blocks, and $\lambda$ can be defined as the product of an average event rate
%$r$ and some time interval $t$.\nolinebreak
\footnote{
%For example, given an average network block intervals of $14$ seconds, the
%expectation that a next block occurs within $3$ seconds becomes $\lambda =
%(1/14) * 3$, yielding $19.2\%$.
    The plot in Figure 17 shows this probability for intervals of 0 through 99
    seconds assuming an average block interval rate of 14 seconds.
}

\begin{equation}
P(E,t) \equiv 1 - e^{-\lambda} \times \sum_{i=0}^{|k|}{\frac{\lambda^{i}}{i!}} 
\end{equation}



\subsection{\normalsize{Probability of a block's canonical state}}

The probability (at the network level) of a block being ultimately accepted as
canonical by the network:

\begin{equation}
P(C) \equiv 1 - \epsilon
\end{equation}

In this simple definition, $\epsilon$ represents the frequency in which a miner
authors a valid block which is not ultimately accepted into the public canonical chain.

We take $\epsilon < 1$ for granted as common sense; canonical blocks exist.
We can also assume that $\epsilon > 0$, since non-canonical blocks exist and
are observable as uncles (also known as "ommers") on chain.

A practical value of $\epsilon$ can be approximated by an empirical measurement
of a network's uncle rate.\nolinebreak
\comment{
\footnote{
  There is a lot to say about this, and the nuances of this idea are important
for understanding what kind of approximation this is, and what its limits are.
  A few brief statements are provided for context below, but should not be
considered comprehensive or definitive:

  The Uncle rate represents a record of the existence of blocks which are not
canonical.
  Iff the revenue for those non-canonical blocks is less than their cost of
production, the existence of any non-canonical blocks implies waste, which
suggests a production inefficiency and an economically undesirable
characteristic.
  From this, understanding that the uncle records provided on chain are
potentially incomplete records of the existence of non-canonical blocks.

  %% TODO
  We might explore this further by look at the rewards more closely.

  Is it actually reasonable for a miner to record an uncle, getting the
  other miner paid? Or are uncles only recorded when the author of the
  canonical block is also the author of the uncle?
}}
Given that observable orphan data on chain may not be complete,
we can derive a reasonable expectation for $\epsilon$ using a
theoretical model, as follows.

Assume that for some time interval (eg. 1 second) a (one) block has been created.
We model the probability, then, for the case that \emph{another} block
will \emph{also} be created in that same interval.

\begin{equation}
    \epsilon \equiv \frac{\frac{1}{14}^{k=1}e^{-\frac{1}{14}}}{k=1!} = 0.066504484...
\end{equation}

The value $0.0665...$ represents the probability that for this arbitrary interval,
at the network level, another (one) block is also found.

To derive the probability of any one miner winning this arbitration,
the network-level probability of orphanhood should be divided by the number
of competing miners (assumed here to be 2).

\begin{equation}
    P(C) \equiv 1 - \frac{0.0665}{2} = 0.96675
\end{equation}

Generalization of this model to any number of near-simultaneous block-production events
is trivial by modifying the Poisson $k$ value, and adjusting the miner share respectively.

\subsection{\normalsize{Network orphan probability}}

The expected network orphan rate is generally the converse of the previous model.

Since the orphan rate for a network can be (albeit somewhat loosely)
understood as the occurrence of at least (but usually only) two blocks
within some interval (usually the network latency variable, but here 1 second),
the expected network orphan rate with these assumptions is around $0.0665$.

We can extend this definition by including cases where another one \emph{or more} blocks
are found in the given interval.

\begin{equation}
    \sum_{k=1}^{\infty}\frac{\frac{1}{14}^{k}e^{-\frac{1}{14}}}{k!} = 0.068937
\end{equation}

Note that as the considered interval\textsubscript{1 second} changes, this value will change,
and that determination of this interval should be made
with respect to relevant estimated network latencies.\footnote{
Network latencies between miners are more relevant, for example,
than latencies between non-mining nodes.
}

%% This is commented!
\comment{
Given our assumption of the Poisson Distribution fit for network block intervals,
we can set Poisson's $k$ value to 2, representing the occurrence of 2 blocks.
Using the Poisson Probability Mass Function, we see that given an average block
interval of $1/14$ seconds, the probability of seeing $k=2$ blocks in some
interval $t=1$ seconds
($\lambda=\mathrm{rate}*\mathrm{interval}=1*\frac{1}{14}$) is:

\begin{equation}
  \frac{\frac{1}{14}^{2}e^{-\frac{1}{14}}}{2!} = 0.00237516...
\end{equation}

But we must extend this to represent the probability of seeing $2$ \emph{or
more} blocks.
We approximate a generalization, using $99$ as an arbitrary upper limit for the
considered number of potential blocks\footnote{The number of potential blocks
is the number of miners on the network.} occurring in the interval:

\begin{equation}
  \sum_{k=2}^{99}\frac{\frac{1}{14}^{k}e^{-\frac{1}{14}}}{k!} = 0.002432736...
\end{equation}

%% Wolfram:
% Sum[Power[(60/14),k]Power[e,-60/14]/k!,{k,2,99}]

% Probability of 1 event in 1 interval
\begin{equation}
    \sum_{k=1}^{1}\frac{\frac{1}{14}^{k}e^{-\frac{1}{14}}}{k!} = 0.0665044842...
\end{equation}

\begin{equation}
    \sum_{k=1}^{99}\frac{\frac{2}{14}^{k}e^{-\frac{2}{14}}}{k!} = 0.009282400...
\end{equation}

\begin{equation}
    \sum_{k=2}^{99}\frac{\frac{3}{14}^{k}e^{-\frac{3}{14}}}{k!} = 0.019928450...
\end{equation}

\begin{equation}
    \sum_{k=2}^{99}\frac{\frac{4}{14}^{k}e^{-\frac{4}{14}}}{k!} = 0.033814908...
\end{equation}

% 0.2642411176571153568089524596770782651083777379364643309843263966...
\begin{equation}
    \sum_{k=2}^{99}\frac{\frac{14}{14}^{k}e^{-\frac{14}{14}}}{k!} = 0.264241117...
\end{equation}

% 0.9272485558395907416045300561128228868543525343254139440341029213...
\begin{equation}
    \sum_{k=2}^{99}\frac{\frac{60}{14}^{k}e^{-\frac{60}{14}}}{k!} = 0.927248555...
\end{equation}

% TODO/Dan Please help me with math here.
% What does Poisson think our expected uncle rate is?
% We know the lambda (1/14).
% We know its a Poisson Process/Distribution.
% We want to know the probability of 2 or more events occurring

Since by definition the canonical state is applied exclusively to 1 of
$\geq 2$ block occurrences, we have shown that even under an idealized game,
the theoretical $\epsilon$ value is a positive, small, number.
} % end comment!

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{\normalsize{Discussion}}

\subsection{\small{Segment-Specific Transactions}}\label{subsec:small{segment-specific-transactions}}

\textit{Ancestor Hash Appended} typed transactions are proposed
as a scheme to implement a general task: limiting transaction availability
such that public chains are prioritized to the exclusion of private chains.

% Transaction/Segment exclusivity is important because differential TABS depends on differential txes.
The effectiveness of Total Active Balance measurements on any chain (segment)
as a decisive factor in consensus scoring depends on transactions having segment-specificity.

Without segment-specificity, in the scenario of a double-spend
an attacker would be able to replay all transactions (save one) from the public chain on their private chain,
thereby equalizing total active balance values.

There are ways under the existing protocol that segment-specificity is practically imitable,
though this option and others like it are limited compared with the proposal outlined below.

For example, a private messaging service, like e-mail,
could be used to send transaction information exclusively to a subset of miners.
In this context, the sender trusts some miner to handle a transaction privately until their next block composition.
But this example depends on a unilateral trust between the transactor and their miner of choice.
The transaction could be resold, publicized, ignored -- all at the miner's discretion.

\textbf{Observable Finality Confidence}

Another benefit of implementing segment-exclusivity at the protocol level
is that it becomes an \textit{observable} expression of a chain state dependency.
On reading a demand on some chain state at a block $H_n$, the transaction expresses
confidence in the finality of that state $H_n$.
Taken together, transactions expressing these dependencies provide
observable, objective traits that can be used for inferences about chain state finality in general.

Since the usefulness of the proof-of-work blockchain depends on users
having effective judgements about an always imperfect state finality, establishing an
on-chain and observable value suggestive of assumed finality should help
transactors make better judgements about block delay intervals for off-chain elements of transactions, for example.

\textbf{Practical Implementation}

In the annotation of the proposed field, the transaction sender makes reference to an observed state of the blockchain.
The observation of and reference to chain state is an incumbent pattern of practical use.
Under the current protocol, transaction senders commonly reference an observed chain state to
establish or validate their transaction's Nonce, the current \textit{Chain ID}, their balance, current gas prices,
and current gas fees (for smart contract composition).
The citation of an observed block hash does not impose a practically novel demand on block state observation.

Moreover, the ability for a transactor to declare a dependency on some observed block state
enables them to make these established habits and practical assumptions explicit.
The chain a transactor sees becomes a chain they can demand.

\textbf{Lesser Availability, Same Throughput}

In database contexts, "availability" (aka "liveness" for some),
is the likelihood that a valid transaction will actually be processed by the database.

By definition, the application of AHA transactions restricts transaction availability
because it limits the state(s) of the database to which the transaction can be applied.
The limitation makes the interaction with invisible or otherwise unknown states impossible.

In this way, database availability is reduced in a desirable way, and without effect
on "throughput" capacity under normal chain-growth.
Throughput is only diminished when unexpected (ie. private) states overtake public ones.


% Model:
%    x = The number of transactions, expressed as a ratio of gas used over gas limit. Mean.
%    y = The depth of transaction dependency, expressed as a difference between block heights. Mean.
%    z = The value of the transactions toward the consensus arbitration algo, eg. sum balances. Median.

%    \begin{center}
%        \begin{tabular}{ c c c }
%            cell1 & cell2 & cell3 \\
%            cell4 & cell5 & cell6 \\
%            cell7 & cell8 & cell9
%        \end{tabular}
%    \end{center}
%
%    \begin{tabularx}{1.0\textwidth} {
%         >{\raggedright\arraybackslash}X
%         >{\centering\arraybackslash}X
%         >{\raggedleft\arraybackslash}X  }
%%        \hline
%        item 11 & item 12 & item 13 \\
%%        \hline
%        item 21  & item 22  & item 23  \\
%%        \hline
%    \end{tabularx}


% ----
%
%The consensus properties of so-called Nakamoto Consensus are well studied.
%% TODO this is an actual quote from a so-called paper.
%
%We seek to show that an implementation of the proposed AHA/TABS protocol for a PoW network
%either preserves or improves key characteristics of network behavior and usability.
%
%We provide the outcomes of two programmatic simulations as experimental evidence of our claims.

\subsection{\normalsize{Chain-Growth}}

Under Nakamoto Consensus, aggregate block difficulty ($H_d$) plays two roles:
pacing block production and nominating canon eligibility.
Since the proposed TABS consensus arbitration algorithm modifies the role of difficulty in canon-arbitration,
it must be shown that chain-growth pacing and the incentives which drive it remain intact.

We follow a \textit{reductio ad absurdam} argument to demonstrate that the proposed modification
of the consensus protocol does not violate any pre-existing assumptions or conditions about the
physics or economic incentives of the block production race.

%First we look at the incumbent assumption and behavior around Total Difficulty, specifically tie (symmetric) scenarios.

The step function which describes chain difficulty and the incumbent consensus arbitration is parametrized by
parent difficulty, current block time, and whether the current block cites any uncles.\footnote{
    The difficulty function analysed is that of the current Ethereum Protocol at the time of writing,
    and includes EIP-100.
}

Each step has a domain of 8 seconds.
So, holding parent and uncles constant, blocks produced in the 1-8 second range yield equivalent difficulties.
Same for blocks with 9-17 second intervals, 18-26 seconds, and so forth.

We note also that the variable inclusion of whether a block includes uncle references
extends the domain (time intervals) of equivalent outcomes to 16 seconds.
    A block produced at $t=3$ without uncles is canonically-equivalent to
    a block produced at $t=8$ without uncles and
    a block produced at $t=17$ with uncles.

Since a block produced at $t=1$ and a subsequent, competitive block produced at $t=4$ would be assigned
\textit{at least} the same canon-arbitration score, and yet it does not appear to be the case that block heights are intentionally
mined for the duration of their competitive interval for some block height,
we must infer that some incentive exists for the miner to mine the \textit{next} block;
rather than pursue a later-occurring but equivalent (or better) canon-scoring block.

We provide a rationale for this phenomenon in the following charts.

%Empirically, around fifty percent of all blocks produced occur in the $[1-8]$ second interval,
%giving them equivalent Total Difficulties.\nolinebreak
%\footnote{TODO: Cite me. Currently empirical/ETH/stats.go}

\begin{figure}[tph]
    \centering
    \includegraphics[width=1.0\textwidth]{imgs/vis_ethash_difficulty_adjustment.png}
    \caption{
        Parent-relative difficulty adjustment rates over timestamped interval.
        Under the incumbent \mghost protocol, these scores are equivalent with our so-called Canon Score value.
        One can see that a block produced at any time may have one of two Canon Scores.
        This chart was produced by the function \texttt{TestPlotDifficultyAdjustments} in the \texttt{go-tabs-charts} module.
    }
    \label{fig:vis_ethash_difficulty_adjustment}
\end{figure}

\begin{figure}[tph]
    \centering
    \includegraphics[width=1.0\textwidth]{imgs/tdtabs_canon_scores.png}
    \caption{
        Proposed parent-relative canon score rates over timestamped interval.
        One can see that a block produced at any time may have one of five Canon Scores.
        However, these Canon Scores are not all equally likely.
        This chart was produced by the function \texttt{TestPlotCanonScores\_TDTABS} in the \texttt{go-tabs-charts} module.
    }
    \label{fig:tdtabs_canon_scores}
\end{figure}

\clearpage
What is the incentive driving the game's pursuit of the next block, rather than pursuing a (symmetric) competitor?

We define these strategies respectively as ADOPT and ORPHAN.
The ADOPT strategy begins work on a new round, asserting some valid proposed block.
The ORPHAN strategy continues work on the parent round, disregarding some valid proposed block.

\begin{figure}[tph]
    \centering
    \includegraphics[width=1.0\textwidth]{imgs/vis_poisson_game_redblue.png}
    \caption{
        Two rounds are presented for two miners with varying hashrate shares.
        At time $t=14$ a block is discovered.
        Miners choose to either continue play on the current challenge height,
        or they begin a new round.
        The probability of their discovery of a block in the new round (ADOPT strategy) diminishes less
        (has a greater slope) than the persistent alternative (ORPHAN strategy),
        indicating that it is more profitable in expectation for them to begin a new round.
    }
    \label{fig:vis_poisson_game_redblue}
\end{figure}

\clearpage

    \begin{figure}[tph]
        \centering
        \includegraphics[width=1.0\textwidth]{imgs/vis_poisson_lambda.png}
        \caption{
            Scaling expectations for block(s) discovery by modifying the Poisson \textit{lambda} value.
            One notes that the probability value of 0.5 is met at time $t=9$,
            and that empirically about 50\% of blocks are produced within the $1 < t < 9$ second domain
            for the original $1/13 (second)$ lambda value.
        }
        \label{fig:vis_poisson_lambda}
    \end{figure}




%
%IMPORTANT
%
%TABS rewards richer miners more than poorer miner, irrespective of their block production.
%    We want to incentivize canonical block production.
%    However, this reward imbalance is probably small.
%
%
\clearpage
\textbf{Race Event Likelihoods}

Under the current $\mghost$ protocol, we consider the rate of chain growth symmetry as more-or-less
equivalent to the chance of the network's generation of near-simultaneous competitive blocks.
The characteristic of being near-simultaneous gives the blocks equivalent Total Difficulty scores.

The probability of these coincidences are defined above.

Under the proposed TDTABS protocol, this rate of ties
(which are ultimately deferred to later arbitration conditions)
is expected to drop.




%\begin{tabularx}{1.0\textwidth} {
%     >{\raggedright\arraybackslash}X
%     >{\raggedright\arraybackslash}X
%     >{\raggedright\arraybackslash}X  }
%%        \hline
%    Arbitration Condition & Likelihood Decided & Notes \\
%%        \hline
%    $B_{td} > B_{td}$   & 0.8  & Total difficulty comparison  \\
%    $B_{n} < B_{n}$   & 0.0  & Lower height (usually inoperative)  \\
%    $B_{c}$ is self   & 0.1  & Prefer self-authored blocks  \\
%    $50/50$   & 0.1  & Coin toss  \\
%%        \hline
%\end{tabularx}
%


%
%What is the likelihood that a miner is able to be differentially competitive as a result of TABS?
%
%We first need to assume some number of transactions per block, and an average balance for those transactions.
%
%Let's assume block space is scare (there are sufficient public transactions available to fill any block).
%We model an average number of transactions per block as the block's gas limit allowance divided by the average
%gas use per transaction.
%Let's say this gives us an average of 300 transactions per block.
%
%




%From this, we can deduce that for the game of the block race,
%a block's publication time priority is critically important to its chance of canonicalization.






%
%In the case of a block A produced within a Difficulty interval X with a decremented TABS score
%and
%a block B produced within a Difficulty interval X+1 with an incremented TABS score,
%the resulting Canon Scores of these block will be equal.
%
%We consider these relative adjustment factor values to represent an equilibrium.
%Remembering that under the current protocol, blocks may be produced in a sequence within 8 seconds of each
%other and result also in a Canon Score tie, we hone our intuition to see that these theoretical
%ties in cases of sequential (non-simultaneous) blocks are disincentivized and thus practically edge cases.
%Miners are incentivized to work on the latest block available to them despite an available consensus tie scenario,
%so we do not expect rich miners to chase authorship of slow-rich blocks following the observance of fast-poor blocks.



\begin{equation}

\end{equation}



% ---

\comment{
        expected profit = miner.hashrateshare X prob of block production X prob of canonical X block rev
        S = miner hashrate share
        R = block revenue
        p(t) = S/1 X p(e, t) X p(c)~0.96 X R

        current:
        t=0
        minerA finds block at t=0
        minerA -> p(t) = p(c)~0.96 X R [block.t=0] + p(t) [block.t>0]
        minerB -> p(t) = S/1 X p(e, t) X p(c)~0.96 X R [block.t>0]

        The best minerB can do is tie. minerA has a 1 block head start.
        By mining on block.t=0, minerB removes the (most of) minerA's head start (though minerA still has latency head start)

        proposed:
        t=0
        minerA finds block at t=0
        minerA -> p(t) = p(c)~0.96 X R [block.t=0] + p(t) [block.t>0]
        minerB -> p(t) = p(t) [block.t>0]


        real numbers

        t=0
        minerA finds block at t=0
        they have 93\% chance of keeping that block
        minerB: 50\% network hashrate, receive block 0.5 seconds later (latency),


    }



\comment{Because the TABS adjustment rate is equal to or less than that of Difficulty in all cases,
    we can show that PoW mining remains the primary driver of chain-growth.

%Increased difficulty, increased TABS.
%Increased difficulty, stable TABS.
%Increased difficulty, decreased TABS.
%
%Stable difficulty, increased TABS.
%Stable difficulty, stable TABS.
%Stable difficulty, decreased TABS.
%
%Decreased difficulty, increased TABS.
%Decreased difficulty, stable TABS.
%Decreased difficulty, decreased TABS.

% Relevant cases:
    A: Difficulty+, TABS-
B: Difficulty0, TABS+
    => B

    \begin{equation}
    (H_d + \frac{H_d}{2048})
        \times (H_k - \frac{H_k}{2049}) > (H_d + 0) \times (H_k + \frac{H_k}{2049})
    \end{equation}

    \begin{equation}
    (H_d + \frac{H_d}{2048})
        \times (H_k - \frac{H_k}{2049}) > (H_d + 0) \times (H_k + \frac{H_k}{2049})
    \end{equation}


    A: Difficulty+, TABS-
B: Difficulty-, TABS+
    => A


    \begin{equation}
        \mathrm{TCS} \equiv \sum_{H_\mathrm{i = 0}}^{\mathrm{i <= n}} H_d
    \end{equation}


    (12947922331000968 + 12947922331000968 * (1/2048)) * ()

    \subsection{\normalsize{Decidability Matrix}}

    TABS is expected to increase network decidability (and thus finality) rates.
% aka canon-arbitration asymmetry outcomes, aka decrease number of ties

    \begin{tabular}[pos]{cols}
        table & content
    \end{tabular}

}
\subsection{\normalsize{Network block emission rates}}
% This should include fork (noncanonical) and canonical block production.

We can reframe the previous section's theoretically modeled orphan rate
as an indicator of what some domain literature considers "symmetry" during "chain-growth."\nolinebreak
\footnote{Narula, 2021.}
The coincidence of block emission occurrences is an event of chain-growth symmetry.
Since only one block may be ultimately selected for the canon, we consider the rate of orphan production
a measure of network \emph{efficiency}.
Orphan blocks represent wasted electricity on behalf of the orphan miner,
as well on behalf of miners who mine on top of it.\footnote{
    Compensating for orphans is the main objective of the GHOST protocol,
    which specifies increasing difficulty for blocks with uncle citations.
}

The AHA/TABS protocol is expected to reduce the orphan rate of the network by increasing decidability (asymmetry)
during canon-arbitration by virtue of an assumed asymmetry between sequential block Total Active Balance values.

Block emission rates will not change.
Emission rates are a function of difficulty, which is codependent with block intervals.
The expected reduction in network waste will \emph{not} ultimately cause faster chain-growth.
Instead, it will cause an increase in \emph{finality = canonical} rates for proposed blocks.
There will be fewer uncles.

%TODO/Isaac
Should uncles be rewarded less? More? The same? \#\mghost.

\subsection{\normalsize{Miner incentives}}
% Miner incentives are assumed as the driving economic factor for block emissions.

Where Total Difficulty alone drives the \mghost and Nakamoto protocols,
AHA/TABS introduces another variable in the miner's efforts to produce a canonical block: transaction sender balances.
Since this value should be expected to impact their probability of a canon win, we should expect them
to prefer transactions with senders of greater balance over those with lesser.

%TODO/Isaac
To what degree should miners prefer transactions and their balances over puzzle solutions?
Will slower blocks win more than they do now?
Will rich miners win more blocks than poor miners?

* Because we assume that miners (entities) hold minority shares of hashrate (no 51+\%s),
we expect that the most profitable strategy for miners is to mine on top of the last best
block they observe.
We can thereby expect that puzzle solutions will continue to be
the primary driving factor for chain-growth.

Do we expect any additional vulnerabilities to malicious behavior?
Can the TABS Canon Score be exploited to allow slower blocks produced by rich miners to win?

When could a slower block produced by a rich miner win?
Block difficulty function is a step function parameterized by block interval.
We assume two blocks:
- A: t=9
- B: t=10

... For blocks produced within some network latency of each other, but occupying
different steps in the difficulty function (thus, different TDs):

1 / 2048
2 / 2048 with uncles = 1 / 1028

minimum difficulty = 131072
current difficulty =
ETH: 14615997 #0xf378378d0575b8ed5ac48434173a61f29b693a20a46623dbda4094114fe04365 D=12,947,922,331,000,968
ETC: 14961128 #0x20cceb7960ce30edea9c5f2b817a861ecf7ebe5b0f7a518a4f6fdd1538046921 D=00,357,336,764,833,767

d * tabs < d * 1027/1028 * tabs * tabs_multiple
1 < 1027/1028 * tabs_multiple
1028/1027 < tabs_multiple

but as written: tabs_multiple = 1/128

\subsection{\normalsize{Transaction availability}}
% Transactors on chain want to have their transactions processed by the miners.

Poor transactors should expect lesser transaction availability,
richer transactors should expect greater availability.
Overall network transaction availability is preserved as an invariant.

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{\normalsize{Program Models}}

The theoretical models described in the previous section serve to
frame our understanding and expectations for programmatic simulations.

We use two computer program simulations to model competitive block emissions.

\texttt{go-block-step} models block emissions from the network level.
It tests and compares simulated network emission outcomes
against the expected Poisson distribution of block time intervals.

\texttt{go-miner-sim} models block emissions in an "actor-based" way,
simulating block emissions given a set of independent miners following a common protocol.

As neighbors, these models can be considered as 'top-down' (\texttt{go-block-step}) and 'bottom-up' (\texttt{go-miner-sim})
approaches to network block emissions and consensus modeling.

We compare the data produced by these programs with empirical chain data, testing for representativeness.
We want to understand the change the TABS protocol presents on block emissions rate,
network consensus rate, miner incentives, and transaction liveness\nolinebreak
\footnote{\emph{Liveness} is a database-jargon term used in several related and referenced papers.
In this context, it is the general chain state's processing of available transactions.
}.

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{\normalsize{Model Comparison: Fork Rates}}

We have now two models which can be used to estimate fork rates during
simulated chain growth. We compare the information provided by these models with
empirical data.

We are concerned with fork rates because a fork represents, by definition, an
instance of reduced finality. Only one block per block number can be ultimately
considered canonical; the others will become obsolete (impermanent).

The ambiguity of \emph{which} block shall become canonical is a matter of
network, and miner, efficiency. Time and energy spent on impermanent blocks is 
wasted.

We note further, that the cost of forks are not limited to the two (or miner)
beneficiary authors of those blocks. We can consider, as an example, that each
of two miners broadcasts their candidates to the network nearly simultaneously.
Attributed to network latencies and graph shapes, the network consensus bifurcates
and global hashrate is halved (each miner having won-over half of the network).
At this point 50\% of network hashpower will be ultimately wasted; only one
side of the fork will ultimately become canonical. The cost of the ambiguity is
borne by all players (though not necessarily fairly distributed).

This assumed state of ambiguity of the candidate blocks is the result of the
canonical arbitration algorithm. A canonical arbitration algorithm yielding a
lower ambiguity rate will reduce the network's block emission waste and improve
expectations of permanence for the overall chain state.

\subsection{\normalsize{Simulated Fork Rates vs. Empirical Uncle Rates}}

We know that uncle rates represent a theoretical minimum measurement of actual
orphaned block rates; the orphans \emph{may} be recorded but are \emph{not
necessarily}.

Can we use an economic model of the incentives of orphan records to suggest to
what degree empirical uncle block rates suggest a complete record?
If miners are not incentived to record orphans they do not mine themselves,
then the recorded orphans will omit those. On the other hand, if it is
profitable for the miner to record orphans regardless of their author, then we
should expect the record to be more complete.

The revenues from orphan recording are inuitive; they are clearly defined and
scaled to the block reward. They are positive. But what are the costs of
recording an uncle?

Total network Wei supply is assumed to be finite for the sake of
argument.\nolinebreak
\footnote{This is not a guarantee for Ethereum, though it is for Ethereum Classic.}

Since an orphan record benefits the miner of the orphan \emph{more} than it
benefits the recording miner, we are lead to reason that it \emph{may} be that the
cost of distributing \emph{any} capital to competitors dilutes the value of a
miner's own capital.

We leave this line of reasoning open-ended.

For the sake of our proposed model, it is enough to assume an observable
objective measurement (uncle rate), and to handle it as theoretical minimum
proxy for actual fork rate.

We turn to empirical data.

At the time of writing, Etherscan.io\footnote{\url{https://etherscan.io/uncles}}
shows $1,207,850$ recorded uncles and a current canonical height of $13,753,436$. 

\begin{equation}
  1207850 / 13753436 = 0.0878217
\end{equation}

We interpret this as representing an orphan rate of about 8.7\%. 

Comparatively, using the \texttt{main} program we simulate a network with
$\lambda=14$, $\eta=1.5$, $8$ miners with hashrates distributed as an
approximate long-tail, at a tick interval representing $100$ milliseconds, over
$10,000$ samples, and yielding a fork rate of 8.39\%. 

Raising latency to $\eta=2$ can raise the rate to 11.7\%.
Alternatively, raising the number of miners to $16$ seems to raise the rate to
around 8.7\%.

It is tempting to manipulate modeled latency values in order to meet the
shape of empirical block interval data. But we must resist this temptation.

We do not know real network latency values, and have no objective way of
measuring them. Further, we expect that even reliably measured subjective values
would vary and are regularly subject to change. This point is especially
pertinent when latency is considered as both mechanically-derived (tube limits) and
arbitrarily decided values (eg. selfish head-start delays).

\begin{wrapfigure}{r}{0.5\textwidth}
    \centering
    \includegraphics[width=0.5\textwidth]{imgs/sim_a_anteater.png}
\end{wrapfigure}

We note, however, that under this simulation, the generated block interval
distribution (Figure right) doesn't seem to match the empirical data.
The intervals are too small.

If we re-prioritize the fit to a back-of-napkin same-shape rubric on block
intervals, a $\eta=4.2$ approximates a better fit (Figure 25, below). At this
latency rate, the model yields a simulated fork rate of approximately 23.5\%.
A Poisson distribution sampling for the same tick duration is overlaid in red.

\begin{figure}[tph]
    \centering
    \includegraphics[height=8cm]{imgs/sim_a_bravo.png}
    \caption{
      Poisson Distribution interval distribution samples
      overlaid on simulated intervals.
    }
    \label{fig:sim_a_bravo}
\end{figure}

Our intention is not to build a best-fit model for empirical data.

Rather, the intention for the model is to adequately theoretically represent the game
which drives the PoW network. With a model that \emph{behaves like} the real
world in its key measurements, we can explore the impact of the proposed
algorithmic modification to the canonical selection logic.

\subsection{\normalsize{
    Comparing Simulated Fork Rates:
    Proposed vs. Incumbent Canonical-Selection Algorithms
}}

When an event $k \geq 2$ occurs, network protocol defines a set of rules for
determining (deciding/arbitrating) canonical status for exclusively one event
(where an 'event' is equivalant to an eligible block).\footnote{
  In fact, the protocol design for canonical-selection is applicable to \emph{all}
  scenarios of canonical-status arbitration between \emph{any} two blocks.
}

We compare the incumbent Total Difficulty (TD) condition with the proposed
Total Difficulty $\times$ TABS (TDTABS) condition by replacing the arbitration
logic used by the model in scenarios (block-space rounds) with $2$ or more
candidate blocks, focusing on the respective rates of 'decidability', where
the condition returns an unambiguous choice for the canonical block.

Under the same conditions of the scenario presented in the previous section,
we find the following exemplary values:

\lstinputlisting[language=]{main_output_charlie.txt}

%Of note here, we find the \textit{ArbitrationDecisionRate} (and
%complementarily, \textit{ArbitrationIndecisionRate}).

The TD model shows a decision rate of 3.9\%, and an ambiguity rate of 3.6\%,
where both rates are measured against total rounds.

The TDTABS model shows a decision rate of 5.1\%, and an ambiguity rate of 2.5\%,
where both rates are measured against total rounds.



%% \comment{
%% In the development and proposition of the canonical-selection algorithm
%% modification, we're interested in a few key features:

%% - Improving finality. \\
%% - Not breaking game theoretical/economic incentives. \\
%% - Not worsening the utility or potential work of the system (ie. same or more
%% possible transaction throughput). \\
%% }


%% \comment{
%% Ethereum rewards the production and recording of uncles.

%% Although the authors are here tempted to dive into the nuances (and history)
%% of uncles, for the sake of the necessary arguments in this paper they will
%% instead assume that
%% While a citation would be nice to suggest that this is common knowledge, we
%% can also use our understanding of Ethereum to derive a rationale of existence
%% of this number, \textit{at least some positive value}, independently.

%% In Ethereum, Uncles is the pet-name/jargon given to forking blocks.
%% Specifically, to the blocks of a fork which do not ultimately wind up being
%% considered canonical.
%% Ethereum rewards the production and recording of uncles. Both the miner of
%% the uncle and of the canonical block (recording it) are rewarded.\nolinebreak
%% %\footnote{
%% Historically, the rewards for uncles and their citations have been changed.
%% In the good old days, Uncles got rewarded a lot more than they are today.
%% Something like $\frac{32-uncleDepth}{32}\mathrm{10^{18} Wei}$ (but don't 
%% quote
%% me on that).
%% Much closer to the reward of the canonical block, and (I believe)
%% benefitting both uncle and canonical miners by equal margin.
%% A lot of uncle blocks got mined.
%% It was kind of a problem. (Or \textit{was it?})
%% Anyways, now, they pay less for orphans.

%% So there are economic incentives to publish, observe, and record uncle block
%% information.

%% And, indeed, uncle block information is published.
%% %% TODO: Cite me.
%% Reliable records of complete uncle block information are, however, imperfect.
%% %% TODO: Say more about why uncle block information is imperfect, and what
%% those shortcomings mean for this analysis.

%% For the sake of argument, we assume from here that Ethereum Uncle rates
%% hover around at least 5\%.
%% }

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagebreak
\section{\normalsize{THE REST OF THIS IS UNEDITED CRUFT}}

Here be dragons. Ye be warned.

\subsection{\normalsize{Probability of canonical acceptance of an eligible
block by the network}}

Intuitively (and ideally), this value is 1. 
Empirically, this value is less than 1.

We attribute this to network latencies and network graph shapes.\nolinebreak
\footnote{
Plural forms are used to emphasize that these values are variable.
Both values are difficult to measure objectively with a high degree of
confidence.
}

Scenario:

Blocks are produced independently and simultaneously by at least two miners.
These blocks have equivalent Total Difficulty values and numbers (for the sake
of argument).
We assume that the network is bifurcated (forked). For sake of argument, we
assume 50\% of the network (by hashrate, say) is on one side of the fork, and
50\% on the other.

Assuming `good` data availability is maintained for \textit{the whole network},
we expect that the fork to resolve quickly.
Probably one side of the fork will produce a block quicker than the other,
yielding a subtree with a greater Total Difficulty value than either of the two
forks previously.
This 2-block chain segment is expected to be adopted as canonical as soon as it
is made available to a node.
For 50\% of the network, this will result in a minus-1/plus-2 block reorg. For
the other 50\% who were originally on the eventually-winning segment, no reorg
is required and the next block is appended. Consensus is reached again.

The general case for the expectation of this resolution is the probability of
simultaneous block production in a series of arbitrary length.
If we define the probability of simultaneous block production as $P_s$,
then it follows that the probability of a bifurcation enduring $n$ blocks
(where $n$ must be greater than 0) be $(P_{s})^{n}$.

Next, we must examine more closely the criteria for what has been called
simultaneity.
In fact, we mean `nearly simultaneously`, or `functionally simultaneous`.
We can loosely establish the bounds for this window from assumed (or measured)
network latency values.
Blocks produced independently within some time interval shorter than the
involved network latencies (ie. between the two competing miners)
will cause each miner to deviate from the optimal protocol (mine the best block
available), because while the next best block available will exist at the
network level,
it will not be available to \textit{them} because of the mechanical limitations
of the network.

We have variables defined for this scenario.

$\lambda$ represents network mean block time in seconds.

$\eta$ represents block message latency between two nodes in seconds.

If we assume a Poisson Point Process distribution for the independent miners,
what is the probability expected for 2 independent new-block events to occur
within an interval $\eta$ of each other?


\subsection{\normalsize{Impact of Proposed Algorithmic Condition on Network
Consensus}}

Conceptually, TABS relies on a fundamental assumption: capital is not
distributed evenly.
If we hold transaction availability to miners constant, in order for TABS to be
effective, we must assume that miner balances are not equal.
If all miner balances are equal and transaction/block inclusion is held
constant, TDTABS does not modify the expectations of an incumbent TD-only based
algorithm.

Assume a waste rate for the network of 5\%.
The Ethereum network's current uncle rate is 5\%. We consider this a minimum
value (there could exist unrecorded/unobserved uncles), but all recorded uncles
are observable and valid.
We assume that uncles are economically undesirable (compared to full blocks),
and as such, that their existence is optimized at the lowest level mechanically
possible.
The occurence of an uncle signals an instant of network consensus
undecidability.
An uncle represents a fork.
An indecisive event signals a lower state finality expectation than a decisive
event.
It also signals, for the miners of each twin block, a reduced expected revenue
for that block (since the probability of impermanence is greater than for an
uncontentious block).

We use Digiconomist data from 20211203 claiming 92.42 TWh as Ethereum's
annualized energy
consumption.\footnote{\url{https://digiconomist.net/ethereum-energy-consumption/}}

94.42 TWh \rightarrow MWh = 94420000 MWh

We then cite
Wikipedia's\footnote{\url{https://en.wikipedia.org/wiki/Cost_of_electricity_by_source}} data for projected LCOE by 2025 (as of 2020) for US simple average cost for
advanced nuclear energy as \$81.65 / MWh.

94420000 MWh \times \$81.65/MWh \equiv \$7,709,393,000

If TDTABS reduces network block waste from 5\% to 2.5\%, that suggests an
approximate annual global savings of \$192,734,825.




\subsection{\normalsize{When Should Miners Mine on the Next Block?}}

\pagebreak
\section{\normalsize{Rationale}}

\pagebreak
\section{Placeholder}
\subsection{\normalsize{Transaction Ancestor Hash}}

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \vspace{6cm}
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\normalsize{Another Thing}}

\pagebreak
\section{\normalsize{Theoretical Analysis}}

This section provides reasoning around the theoretical implications of the
proposed algorithm.




\subsection{\normalsize{Network Behavior Analysis}}

Demonstrate that the `objectivity` characteristic of consensus-facing
information is invariant.
The additional observable data required by the proposed algorithm is chain
data. It is in the same scope (`context`) as data relied on for the existing
canonical-preference scheme.
All nodes can make the same decision given the same information at any point in
time.

Need to show that consensus properties for the network are invariant.

Demonstrate that the incentive to mine the NEXT BEST block (ASAP) is preserved
as an invariant.

Consider also:
- theoretical additional block processing cost (\textit{more} to do)
- necessity of observable chain state (well, only balance) for block
validation. Compare with requirement of Ethash for block validation. Compare
with other validations, eg. Parent Hash, Number.

\section{\normalsize{Game Theoretical Analysis}}

Show the equation of miner predicted (expected) revenue for some (next) block.
Next blocks are uncertain, future events.
We can show the probability of some miner winning the next block as the plot of
the percentage chance of next-block being found over time, divided (scaled) by
their relative hashrate.
We show that for t=0..t=n that the expected revenue of the miner goes up.

We consider this plot for the scenario where a miner observes a next block.

\subsection{\small{Placeholder}}

\section{\normalsize{Economic Analysis}}

\section{\normalsize{Practical Analysis}}

This section offers analysis and interpretation of empirical and derived data.

\pagebreak
\section{\normalsize{General Proposition}}

We want to improve chain state finality characteristics without compromising
other security characteristics of PoW network protocol.

We propose the introduction of segment-specific transactions and an accounting
on a representative measure of capital saturation for some segment, yielding a
"hybrid" canonical-score value.

We intend to extend the incumbent PoW canon-arbitration protocol to include
reasoning about segments' relative "capitalization" rates.
The introduction of such a variable can be shown to raise the expected cost of
an alternative-history-based attack and to have minimal negative side effects.

We get to to keep, and still deeply rely on, an incumbent PoW emission and
consensus pattern.


% Given: \\
% - A non-zero (the more the merrier) rate of transactions on the network. \\
% - A non-zero rate of segment-specific transactions (a "large" $\tau$). \\
% - A 51\%-attack scenario. \\



\section{\normalsize{Open Questions}}

\subsection{\small{What if emissions revenues were separated from tx processing
revenue?}}


\subsection{\small{Can we show that 3\%/97\% is a sensible
simultaneous-production rate using just the Poisson emission
model?}}

NOTE that we don't assume perfect simultanaeity; the Poisson model forbids this.
We set a window we define as "competitive." We characterise this by a
heterogenous acceptance of blocks at some number at the network-level; blocks
produced near-enough-to-simultaneously to produce a network fork (of some
scale; a point which could be additionally investigated: to what scale? 50\%
partisanship? 0.01\%?), e.g. 300 milliseconds.

\subsection{\small{Can we show formally that it is game-optimized to mine on
the next block immediately (no matter a miner's own anticipated TABS
score)?}}

We assume under the standard Pow/Ethash game, that it is optimal to always mine
on the greatest block available.
However, we know that this assumption has limits; "selfish" miners with
sufficient relative hashrate (greater than 25 percent) can/should be expected
to optimize toward their own self interest.

Is the strategy around potential witholding of next-blocks maintained as an
invariant?
Is the strategy around mining the best-available block (vs. continuing work on
a potential own fork) maintained as an invariant?

A miner will be able to calculate their anticipated TABS in advance (before the
finalized production of their next block, depending/awaiting an Ethash
solution).
This leads one to wonder: \\
- If a miner foresees a "+" TABS block of their own (eg. they have receive in
private a large transaction to process, or they are just rich), \\
- after an interval of 3 seconds from its parent, child block from another
miner is broadcast having a "-" TABS value. This creates a block with
CS=(2049*127)/(2048*128). \\
- Is a competitive, "rational" miner incentivized to continue mining for some
period of time in the expectation of discovering a block with a comparatively
greater CS? \\
    - If they discover a block at the 8 second interval (5 seconds later),
their block would have CS=(2049*129)/(2048*128). \\
    - BUT, the competing miners will have had a 5 second "head start" on their
\textit{next} block (n+1).

I think this can be solved by finding the relative area under the PDF curve
(CDF?) of the Poisson distribution for that time interval (the chance of
another block appearing).
This value should then be multiplied with the expected value of that next block
(in CS units).

My intuition is that the CS value of a "whole" block is enough greater than the
marginal differences caused by Difficulty and/or TABS adjustments that time
spent toward that whole cookie is more valuable than chasing crumbs.

To demonstrate this, we can show that the CDF (?) of the Poisson distr. for
lamda=13 gives a 2\% likelihood to a next block at the 1-second interval. This
number is totally made up.
We show that 0.02 * NextBlockCS is greater than the marginal difference
possible with the selfish miners competing block.
So the expected value (after some very small amount of time) is higher for our
potentially-selfish miner to pursue the next block instead of their own.

We could add realistic complexity by noting that our potentially-selfish miner
controls some portion of the network hashrate.
Their decision to pursue a selfish block/fork instead of mining the next-best
block would remove hashrate from that block's potential child, thus increasing
the expected interval to that child.
For example, loosely: a miner with 25\% network hashpower could (waves hands)
extend the expected interval for the next block from a lambda = 9 seconds to
9*1.25 seconds = 12 seconds by pursuing their own next block. I have no idea if
this math is reasonable.
Would this mean they have a "free" 12-9=3 seconds to spend in pursuit of their
selfish block?
However, we should also note that the miner, pursuing independent solution,
will have only 25\% of the network's difficulty/hashrate calibration, and so
should expect to see a block production rate averaging 25\% of the network;
this means expecting a slower block production rate (it will probably take them
longer than 13 seconds, eg. 13*4 = 52 seconds).

To account for this last point, we can reuse the CDF logic from above; the
selfish miner's expectation for block discovery in the next 1 second is small
than that of the network.

\begin{equation}
P(\mathrm{hps},k) \equiv \text{probability of discovering Ethash solution in
$k$ seconds given \mathrm{hps} hashes per second}
\end{equation}

- $hps$ will be lower for the selfish miner than for the rest of the network
(in aggregate)


\section{\normalsize{Discussion}}

\subsection{\small{Ancestor Hash vs. Chain ID}}

Background information has been provided in this paper on Chain ID (see Section
1.4)  for the purpose of contextualizing the proposed Ancestor Hash feature.
There are clear similarities. In this section we show that the proposed
Ancestor Hash feature is an generalized implementation of the existing Chain ID
feature.

Chain ID is a single, static, arbitrary scalar value delimiting transactions
per "chain". The meaning of \textit{chain} in this context is congruent to the
border drawn by ticker symbols. At least, this is the scope of which Chain ID
\textit{appears} to have been intended for.

Ancestor Hash proposes a protocol which generalizes the idea of delimiting
transactions by chain. The single, static value is swapped for an arbitrary,
dynamic value; and in turn, the idea of "chain" moves from a segment marked
with a single, hardcoded block (genesisor a fork block), toward an idea that
much more accurately represents and describes the dynamic and occasionally
ambiguous growth of PoW chains.

The job that Chain ID does could also be done by Ancestor Hash. (Though this
paper does not propose replacing it.)
Where Chain ID values are controlled centrally, by developers (via client
release defaults, usually). Ancestor Hash values are determined by transaction
authors (read: chain users).

Chain IDs contain (or \textit{can} contain) very little information compared
with Ancestor Hash.

Ancestor Hashes do not force transactions authors to assume anything about the
chain that they wouldn't otherwise. Or at least, to make no assumptions or
compromises beyond their original, and intuitive, models.

The values that can be annotated are arbitrary. An Ancestor Hash specifying
block 1.912.489 (TODO GET THE HASH) on ETH would be \textit{more} ambiguous
than Chain ID. On the other hand, an annotation citing their latest seen block
represents the maximum expression of confidence (or dependence) on a specific
chain chronology.

It is a way for transaction authors to declare a meaningful confidence interval
(like exchanges do with confirmation delays). The delay enforced by the
exchanges is an expression of doubt; the delay expresses by the transactor is
an expression of confidence. (Exploring the thought experiment further: What
HFC.Hash values would exchanges "like" to see on ETH for token deposits? Short
ones; near the head. The nearer the transaction dependency toward the chain
head, the more likely the deposit is to become \textit{invalid} in the event of
a reorganization. The denser the dependence on the chain head becomes... more
gravity, more finality.)

By expressing a dependency on a specific block, transactions implicitly
\textit{also} express dependency on global chain state, and the transactions
that drive it.

Another thought experiment:

I sell all my Bitcoin because Elon sold his last block. Then, in a twist of
fate (is there such a thing as coincidence?), a two block reorg happens;
removing Elon's sell, but keeping mine.
With HFC.Hash, I could annotate the hash of the block with Elon's transaction
in it. With that specific block missing from the reorg'd replacement block, my
transaction won't be valid, and I won't have sold my Bitcoin like a sucker.

It can be argued that Ancestor Hashes give more control to the transaction
authors in regard: transaction placement and assumptions about state.

We take it for granted that transactors make assumptions about chain state.
When you send some ETH, it's not crazy to check your balance first. To check
your transaction history; to make sure you're on the right nonce.
These are assumptions about chain state. 

Ancestor Hash transactions allow you to express these assumptions. To write
them into code.

\subsection{\small{The Necessity of Ancestor Hash to the Proposed
Canonical-Arbitration Algorithm}}

In the scenario of a malicious chain state-modifying `attack`, an attacker
exploits an assumption by a counterparty on chain state finality.

The fraud strategy is based on the eventual censorship of one or more
transactions on which a reciprocal exchange depends.

We assume that an attacker should only censor transactions on which the attack
depends.

Spurious censorship beyond the interests of the attack results in risky
collateral damage (ie. an increased risk of counter-attack).


\subsection{\small{Ancestor Hash: Database Availability Impact}}

Theoretically, the utilization of Ancestor Hash negatively impacts the
`availability` of the chain state database to pending transactions.

In other words, this reduces the chain's transaction `throughput`.

We argue that the extent to which database availability is restricted is not
necessarily undesirable.
The marginal availability constraint proposed, we argue, aligns with reasonable
assumptions by a transactor about current chain state,
and that the reduction in state database availability reflects potentially
undesirable/spurious transaction inclusion in alternative
and unobserved chain state histories.

\subsection{\small{Will miners include as many transactions per block as
possible? (Is network transaction throughput optimized/invariant?)}}


- Assume "full blocks" (more pending transactions than available block space).
\\
- Assume transactions come from senders with positive balances. \\
- Don't consider: variable balances for transaction senders. \\

The more transactions in a block, the greater the $TABS$ value.
The greater the $TABS$ value, the greater the chance the miner authors a
canonical block.
The more canonical blocks a miner authors, the more money they make.

QED There exists incentive for miners to include as many transactions as
possible for each block they mine.
NOTE as an \textit{invariant} with original \mghost protocol.

\subsection{\small{Will miners prefer transactions from senders with relatively
greater balances?}}

Yes. But transaction gas fees and costs need to be considered simultaneously
(or at least not forgotten).
That is, until $B_{i}_{TAB}$ $>$ $B_{i-1}_{k}$; then it will prefer transaction
gas profit, an \textit{invariant}.

\subsection{\small{Will miners be incentivized to raise the block gas limit
indefinitely?}}

- Assume (or remember) that given sufficient transaction volume for equilibrium
fee competition, miners
  are incentivized to include as many transactions in a given block as possible
in order to maximize
  gas fee revenues by raising transaction volume. \\
- Assume that the existing network's GasLimit has not risen indefinitely. \\
- Assume there exists some reasonable reason for this, like block rationing
processing time and energy,
  network latency optimization, social norms, mechanical ignorance of or
insufficient means of execution (don't know to code it, or don't know how to
code),
  unexplained or unfamiliar (to your authors) distributed decision-making
rationales etc. \\

Given these assumptions, we consider only the game theoretical impacts of
additional transaction inclusion
in regard to $TABS$ and the role of that value in the proposed segment
preference algorithm.

Point 1. GasLimit adjustment bounds can be insufficient to achieve the case.

This is because the minimum cost of a transaction is 23000 Wei.
The current GasLimit is 10.000.000 Wei.
The GasLimit adjustment algorithm permits the change of the incumbent (parent)
GasLimit header value by +/- $B_{i}_{GasLimit}$/1024.
10.000.000/1024 = 9765.63.
9765.63 $\langle$ 23000.
If we assume an initial upward march of the GasLimit (at $B_{i}$), then before
arriving at block $B_{i+3}$ we shall encounter a
block with GasLimit y < parent.GasLimit - (parent.GasLimit/1024), at which
point a further increase to the GasLimit
shall not be sufficient to permit the inclusion of another transaction.
A raise at this instant does not bring any immediate benefit or future
advantage for the block author. In some cases, a raise could benefit the
competiton.
The game equilibrium becomes stasis.

Point 1/Counter 1. GasUsed values are composites of diverse sets of
transactions. It is theoretically possible for GasLimit (at any adjustment
value/rate) to be sufficient to build a case where
the GasLimit should be expected to be driven indefinitely higher. 

For example:

Block.Parent.GasLimit     = 10.000.000 \\
Block.Transactions.GasUsed = 9.985.900 \\
\\
Extra pending TX GasCost = 23000 \\
\\
If Block.GasLimit is raised to 10.009.765, the "Extra" transaction will be
eligible for inclusion (total GasUsed 10.008.900).
Scenarios like this can be built with arbitrary transaction gas costs (eg. EVM
use).
However, practical fabrication of scenarios like this involve centralized
dominance of the pending transaction market (ie. by paying exhorbitant gas
prices, by controlling miners, by suppressing entry to the public transaction
pool, etc.).

If we grant Point 1/Counter 1, are the remaining unconsidered conditions also
sufficient?

(Before we dive into this, we should also remember that an additional,
adjacent, protocol change could be introduced capping the valid GasLimit, or
capping its max adjustment value. Either or both solutions would mitigate the
risk here, and could do so without noticeable effects on the status quo.)

---

It is at this point we need to consider the block production and selection
business of $TABS$.
How does $TABS$ shape consensus? What's its impact on segment selection?

The $TAB$ value for any given block is -- from a block \textit{production}
perspective -- "incidental."
Blocks may (still) be produced with no transactions, and with the block miner
having a 0 balance. This is an invariant.
Also invariant is that block validity depends on a unique, verifiable Ethash
solution; the design and implementation of which remains unchanged.
Nakamoto assumes that an optimized game sees honest, minority miners mining
immediately on any next best block available to them.

We expect about 97\% of blocks produced to be distributed and adopted without
any observable contention. TODO CITE my experimental design and evidence.
Supplementarily, we expect about 3\% of blocks to be contentious (to some
degree at the network level).
Uncle rates typically hover between 3-6\%. Rates in excess of 3\% we consider
to be driven by what this paper considers externalities:

- selfish mining behavior, \\
- variable network latencies, \\
- program processing time and/or priorities (eg. between various client
implementations), \\
- and potentially variable economic conditions (eg. uncle "rewards," which
once-upon-a-time made uncles nearly (if not actually) more profitable than
canonical blocks themselves on Ethereum). \\

NOTE that GHOST (and later, \mghost) specifies difficulty-accounting
for recorded uncles.

THIS IS SUPER IMPORTANT >> NEED TO MAKE SURE ITS WRITTEN REEAALLL GOOOD >

We reason that in 97\% of blocks, the consensus-driving factor will remain the
discovery of an Ethash solution and the prompt composition and broadcast of
that solution.
In these cases, the impact of the $TABS$ value in the $TCP$ product is
ineffectual; a "non-uncling" block discovered in the network mode of 8 seconds
will see
its adoption as canonical regardless of its $TABS$ score; just by virtue of
being first to the solve.

SIDENOTE. As such, we expect the impact of the $TABS$ \times $H_{d}$ scoring
system on overall block production rates to be small.

In the 3\% of cases where honest miners generate simultaneous solutions:

- Assume the usual case where the competition is bilateral (not tri-, or quad-,
etc.). \\
- Assume blocks have equivalent objective consensus-algorithm scoring: total
difficulty, block number. \\
- Assume these two miners each convince 50\% (by hashrate) of the network to
their fork per their network connection graphs. \\

In these cases, a figurative coin is tossed. Each miner wins 50\% of the time.
We see that miners see a 98.5\% "efficiency" rate against their purely
theoretical, independently-considered hashrate.
Another way of saying this: the network operates at 98.5\% efficiency measured
as time and energy spent vs. the "ideal" market value of that work.
1.5\% is lost to the confusion of a competitive, decentralized network; the
ethereal (and theoretical) waste heat of the network.

$TABS$ will have an impact on the outcomes of these 3\% of blocks.
Experimentally, $TABS$ values will supercede what otherwise would become a coin
toss between 50\% and 80\% of the time.
Why?

- Assume 50\% miner hashrate has less, and 50\% more, relative to the
instantaneous network $TABS$ value (at some public chain HEAD (or current
state)). \\
- Assume 0\% frequency of an producing a block with a $TABS$ score equivalent
to its parent. (If/when we relax this assumption, we'll see that the
undecideability rate returns upwards toward that of the proposed algorithm's
predecessor.) \\

In these cases:

- Miners each have a 50\% chance of a "high" $TABS$, and likewise a 50\% chance
of a "low" score. \\

What is the chance of H:L OR L:H (AND NOT H:H OR L:L)? 50\%! 2 of these 4
possible cases are decisive; 2 are indecisive.

And so, in the "flattest" (least colorful, varied... most general) case,
overall miner "efficiency" will increase by 0.5 * 0.5 * 3 = 0.75\% for "rich"
miners, decreasing by the same amount for "poor" miners.
The theoretical network inefficiency (undecidability) rate will decrease by
approximately half.


NOTE FOR ALL OF THIS:
An uncle rate (and the waste-heat theory) is largely a function of block
emission rate.
Faster blocks yield more confusion, slower emission rates see less frequent
simultaneous emission events by virtue of a wider range of discrete emission
times (eg. 1-99 seconds on ETH vs. 480-900 seconds on BTC). (A Poisson model
for emission intervals is assumed.)



\subsection{\small{Hashes vs. ETH: Unit Cancellation in Total Canon
Scoring}}

This section shows in math how taking the product of the Difficulty and TABS
values
yields results that cancel the units (hashes and ETH, respectively). This is
important because there's no good way interchange hashes and token values.

---

In reality, it is likely that many of the characteristics of this general
scenario are less homogenous than assumed.
For example: \\
- Mining hashpower is not evenly distributed. \\
- Capital (ie. tokens) are not evenly distributed among neither miners nor
transaction senders. \\

---

Dad's comments/questions from Thanksgiving:

Difficulty does not have units. It is just an integer.

Rounding errors?
Random walk re: TABS value algo, +/- 1/128 -- does this tend to median? Is it a
random walk?
Why 128?

---\label{subsec:small{transactions-with-ancestor-hash-appended}\label{subsec:small{transactions-with-ancestor-hash-appended2}\label{subsec:small{transactions-with-ancestor-hash-appended}

    \comment{
    SCRATCH Q&A FROM ECIP DRAFT:

        ### What happens if no one uses chain state exclusive transactions?

        The AHA proposal does not define any demand on the use of that transaction type.
        As such, it may be that transactors on the public chain do not make use of it, or use it with distant chain state references.

        The rate at which a private chain cannot include transactions available to the public chain determines the relative, differential finality expectation.

        If AHA is unused or otherwise does not express exclusive demands on chain state, the marginal augmentation of expected state finality under TABS diminishes,
        approaching the expectations incumbent under the proof-of-work protocol without it.

        AHA is NOT the only mechanism that could be used to implement chain state exclusivity for transactions.
        For example, if we explore a thought experiment where the global transaction pool has become disused,
        and in its place convention has become direct-to-miner publication of transactions (say, via email) and that,
        by an incentivized convention, miners do not share their available transactions freely with one another,
        then those "direct-message" transactions will not be available for inclusion on the attacker's chain.

        ### Are richer miners rewarded preferentially?

        Yes, but probably only "a little".

        Richer miners are preferred as a function of the determining factors of probably infrequent tie-break scenarios, eg. orphan blocks (recorded as uncles).

        Assume: Unequal distribution of capital between miners (richness, poorness).
        Assume: Miners are comparably capitalized with any other transactor. (Miner's aren't perfect hodlers.)

        Granted: The TABS adjustment algorithm move TABS toward the median. Half the blocks will adjust it up,
        half down.

        Assume: Miners use the globally available transaction pool.
        Assume: The transaction pool yields some random distribution of values.
        Unknown: The actual distribution (and variance) we should expect for the transaction pool.
        Assume: Normal distribution.

        OK, so, say the miner has 1/300 of the capital available to the block.

        The scenario where the richer miner is preferred over the poorer is:
        Two blocks have been produced nearly-simultaneously, one by the poorer and one the richer.
        The richer is able to achieve a TABS increase because their 1/300 of the represented balance is sufficient, while the poorer's is not.

        The probabilities of our demands:
        Near-simultanaeity. Say, 10% of the blocks produced are time-twins.
        What is the probability that a block n+1 will have a TAB of within 1/300 of the parent n's TABS? (Causing the richer's miner marginal addition balance to be decisive.) Depends on the distribution.



        ### How should miners sort transactions?

        If blocks are not full (block space is not scarce), then sorting is a moot point. Include all of them.

        Sorting by balance can yield a sometimes-higher expectation of canonical status; on which miner revenues depend.
        Miner revenues also depend on transaction fees.

        If the expected benefit (profit) from an additional marginal probability of canonicalization offered by a balance-sort exceeds the marginal losses in transaction fees,
        then the miner should sort by balance. Otherwise, they should continue to sort by fee.

        To the extent that the transaction pool offers unpredictable and variable aggregate balances, incentive to sort by balance is reduced.

        In most cases, the earnest race to discover and publish block solutions will easily outpace any marginal gains offered by balance-based transaction sorting.

        It is important to note that the incumbent protocol does not define a sort order: it is left to the market, to the presumed classically-greedy capitalistic whims of the miners and the developers who build defaults.
        A transaction sort order cannot be adequately defined by the availability of transactions (the "global" transaction pool) to miners is not guaranteed nor within the scope of the consensus-facing protocol.
        Thus, any model or algorithm this proposal provides in this regard should be considered only as an approach to a probably-sane default for an optimization problem, rather than a any demand on validity.

        TODO

        Naive?:
        If blocks are full, then sort by balance while pending TABS score is below that of the parent block.
        If the balances of all available transactions are insufficient to push the TABS value up, use fee sorting instead.
        Problem?:
        This explanation does not have the probability math, and it needs it.

        ### Will miners "stuff" blocks with their own transactions?

        We assume a (some) miner controls some finite amount of capital as blockchain currency (ie balance).
        In the cases where a miner is incentivized to include a self-signed transaction activating their own balance in a block they author,
        one transaction is theoretically sufficient.
        The use of more than sufficient transactions for the purpose is inefficient (and thus disincentivized) because, attributable to the block gas limit,
        they do so at the expense of cannibalizing space (and time) for a revenue-producing transaction.

        So: Indeed, they may "stuff" blocks with transactions of their own, but they expect to profit most
        by using only one transaction (using the least amount of gas) per block.

        ### How much is finality improved?

        Finality is measured as the expected likelihood of some state being eventually and ultimately permanent.

        In the case of a double-spend scenario, the incumbent cost of an attack (ie. a 51% attack) is the cost of capital available to provide the necessary proof-of-work solutions.
        TABS augments this cost by the aggregated balances of the senders of all exclusive transactions in the contending, public blocks.
        If the `gasLimit` is `10_000_000` and the average transaction requires `30000` gas, then a block will fit 333 transactions.
        We define an assumption that the average balance of a transaction sender address is `10ETC`.
        We assume that _all_ of these transactions define chain state dependencies concurrent with the contentious chain segment in question.
        Under these assumptions, the cost of a viable attack is increased by `333 * 10ETC = 3330ETC + epsilon`.

        If we modify the assumptions to use a 50% rate of relevant chain-state exclusive transactions (ie. 50% adoption and relevant use of AHA),
        the value becomes `333 * 10ETC * 0.5 = 1665ETC + epsilon`.

        It is noteworthy that this additional cost does not represent "spent" capital, rather _available_ capital.
        If the required capital is available to an attacker and yet the attack is not successful, the balance capital is recovered while the proof-of-work capital is not.
        An attacker must have _access_ to this additional capital, but does not have to actually part with it.

        ### Are there known vulnerabilities introduced?

        TABS Poisoning

        The attacker attempts to cause the public chain's TABS score to drop by filling the public transaction pool with high-fee, low-balance transactions.


    }

\end{document}
